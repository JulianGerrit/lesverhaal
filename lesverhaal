#!/usr/bin/python3

# Imports and config. {{{
import sys
import os
import re
import crypt
import traceback
import time
import fhs
import websocketd
from markdown import markdown
from websocketd import log
config = fhs.init({'data': '.', 'port': '8000', 'admin-port': '8001', 'loglimit': 2, 'content': 'content', 'lazysave': False, 'secret': '', 'logfile': ''})
logfile = open(config['logfile'], 'a') if config['logfile'] else None
def debug(priority, message):
	if priority <= config['loglimit']:
		log(message)
	if logfile:
		logfile.write('{}: ({}) {}\n'.format(time.strftime('%c', time.gmtime()), priority, message))
		logfile.flush()
import content
# }}}

''' Log priorities: {{{
		0: Critical (system code errors)
		1: Important (user code errors)
		2: Normal (communication notifications)
		3: Debug
}}} '''

# User management. {{{
users = {}	# including admins.
admins = {}

def mangle(src): # {{{
	def escape(x):
		return x.replace('\\', '\\\\').replace(';', '\,').replace(':', '\.').replace('\n', '\\n')
	styles = ':' + ':'.join(escape('/'.join(s)) for s in src[1])
	answer = src[0]
	if isinstance(answer, int):
		return 'i{}'.format(answer) + styles
	if isinstance(answer, float):
		return 'f{}'.format(answer) + styles
	if isinstance(answer, tuple):
		if isinstance(answer[0], tuple):
			if answer[0][0] is None:
				return 'U/{}/{}'.format(escape(answer[0][1]), escape(answer[1]))
			return 'U{}/{}/{}'.format(answer[0][0], escape(answer[0][1]), escape(answer[1])) + styles
		if answer[0] is None:
			return 'F/{}'.format(escape(answer[1])) + styles
		if isinstance(answer[0], int):
			return 'I{}/{}'.format(answer[0], escape(answer[1])) + styles
		elif isinstance(answer[0], float):
			return 'F{}/{}'.format(answer[0], escape(answer[1])) + styles
		else:
			return 'S{}/{}'.format(answer[0], escape(answer[1])) + styles
	try:
		return 's' + escape(answer) + styles
	except:
		debug(1, 'Error: unable to mangle {}'.format(repr(src)))
		return 's' + escape(repr(src)) + styles
# }}}

def unmangle(src): # {{{
	# 'answer:key/value:key/value'
	def unescape(x):
		return x.replace('\\n', '\n').replace('\\.', ':').replace('\\,', ';').replace('\\/', '\\').strip()
	try:
		parts = src.split(':')
		answer = parts[0]
		styles = []
		for p in parts[1:]:
			if '/' not in p:
				continue
			key, value = p.split('/', 1)
			styles.append((unescape(key), unescape(value)))
		if answer[0] == 'i':
			return int(answer[1:]), styles
		if answer[0] == 'f':
			return float(answer[1:]), styles
		if answer[0] == 's':
			return unescape(answer[1:]), styles
		if answer[0] == 'I':
			r = re.match(r'I(.*?)/(.*)$', answer)
			if not r:
				debug(1, 'Error unmangling long int: {}'.format(answer))
				return (None, unescape(answer)), styles
			return (int(r.group(1)), unescape(r.group(2))), styles
		if answer[0] == 'F':
			r = re.match(r'F(.*?)/(.*)$', answer)
			if not r:
				debug(1, 'Error unmangling long float: {}'.format(answer))
				return (None, unescape(answer)), styles
			if r.group(1) == '':
				return (None, unescape(r.group(2))), styles
			return (float(r.group(1)), unescape(r.group(2))), styles
		if answer[0] == 'S':
			r = re.match(r'S(.*?)/(.*)$', answer)
			if not r:
				debug(1, 'Error unmangling long string: {}'.format(answer))
				return (None, unescape(answer)), styles
			return (unescape(r.group(1)), unescape(r.group(2))), styles
		if answer[0] == 'U':
			r = re.match(r'U(.*?)/(.*?)/(.*)$', answer)
			if not r:
				debug(1, 'Error unmangling long unit: {}'.format(answer))
				return ((None, ''), unescape(answer)), styles
			if r.group(1) == '':
				return ((None, unescape(r.group(2))), unescape(r.group(3))), styles
			return ((float(r.group(1)), unescape(r.group(2))), unescape(r.group(3))), styles
	except:
		traceback.print_exc()
		pass
	debug(1, 'Error unmangling: invalid first character of {}'.format(repr(src)))
	return src, ()
# }}}

def load_user(name, group): # {{{
	if (name.lower(), group.lower()) in users:
		return users[(name.lower(), group.lower())], None
	if not os.path.exists(os.path.join(config['data'], 'users', group.lower())):
		debug(0, 'load_user called for nonexistent group {}:{}'.format(name, group))
		return None, None
	if not os.path.exists(os.path.join(config['data'], 'users', group.lower(), name.lower())):
		debug(0, 'load_user called for nonexistent user {}:{}'.format(name, group))
		return None, None
	ret = {'filename': name.lower(), 'name': name, 'group': group.lower(), 'connection': None, 'password': None, 'nosave': False}
	answers = {}
	for ln in open(os.path.join(config['data'], 'users', group.lower(), name.lower())):
		if ln.strip() == '':
			continue
		key, value = ln.split('=', 1)
		if key == 'nosave':
			ret[key] = value == 'True'
			continue
		if key.startswith('answer:'):
			a, s, q = key.split(':', 2)
			q = tuple(int(x) for x in q.split(','))
			if s not in answers:
				answers[s] = {}
			answers[s][q] = [unmangle(a) for a in value.split(';')]
			continue
		ret[key] = value.rstrip('\n')
	# Make sure name and group match file location.
	if ret['filename'] != name.lower():
		ret['filename'] = name.lower()
	if ret['group'].casefold() != group.casefold():
		ret['group'] = group
	return ret, answers
# }}}

def list_users(group): # {{{
	path = os.path.join(config['data'], 'users', group.lower())
	if not os.path.exists(path):
		debug(0, 'list_users called for nonexistent group {}'.format(group))
		return []
	return [p for p in os.listdir(path) if p == p.lower() and not os.path.isdir(os.path.join(path, p))]
# }}}

def save_user(user): # {{{
	'''Save user information to disk. user['connection'] is valid while this is called, but the connection may be closed.'''
	with open(os.path.join(config['data'], 'users', user['group'].lower(), user['filename']), 'w') as f:
		for key in user:
			if key == 'connection':
				continue
			f.write('{}={}\n'.format(key, user[key]))
		# Record answers.
		if not user['nosave']:
			for s in user['connection'].answers:
				section = user['connection'].answers[s]
				for q in section:
					question = section[q]
					f.write('answer:{}:{}={}\n'.format(s, ','.join(str(i) for i in q), ';'.join(mangle(a) for a in question)))
# }}}

def save_users(): # {{{
	for user in users:
		save_user(user)
# }}}

def refresh_admins(): # {{{
	for a in admins:
		admins[a].refresh()
# }}}
# }}}

class Admin_Connection: # {{{
	def __init__(self, remote): # {{{
		self.remote = remote
		remote.closed = self._closed
		self.user = None
		q = remote.data['query']
		keys = ('name', 'secret')
		if config['secret'] != '' and all(x in q for x in keys) and q['secret'][0] == config['secret']:
			if not self._login(q['name'][0], 'admin'):
				self.remote.login.event()
				self.refresh = lambda: self.remote.login.event()
		else:
			self.remote.login.event()
			self.refresh = lambda: self.remote.login.event()
	# }}}
	def login(self, name, password): # {{{
		user, answers = load_user(name, 'admin')
		if user is None:
			debug(2, 'Invalid admin {} from {}:{}'.format(name, *self.remote.socket.remote))
			return False
		crypted = crypt.crypt(password, salt = user['password'])
		if crypted != user['password']:
			debug(2, 'Invalid password for {} from {}:{}'.format(name, *self.remote.socket.remote))
			return False
		if not self._login(name):
			self.remote.login.event()
			self.refresh = lambda: self.remote.login.event()
		return True
	# }}}
	def _login(self, name): # {{{
		user, answers = load_user(name, 'admin')
		if user is None:
			return False
		if user['connection'] is not None:
			debug(3, 'Replacing connection for ' + name)
			try:
				user['connection'].remote.replaced.event()
			except:
				pass
			user['connection'].remote.close()
		else:
			users[(name.lower(), 'admin')] = user
		user['connection'] = self
		self.user = user
		debug(2, 'Admin {} logged in from {}:{}'.format(name, *self.remote.socket.remote))
		admins[name.lower()] = self
		self.list_groups()
		return True
	# }}}
	def _closed(self): # {{{
		self.remote.close()
		if self.user is None:
			debug(2, 'admin connection to {}:{} lost before logging in'.format(*self.remote.socket.remote))
			return
		debug(2, 'disconnecting admin {}'.format(self.user['name']))
		try:
			users.pop((self.user['filename'], 'admin'))
		except:
			pass
		try:
			admins.pop(self.user['filename'])
		except:
			pass
	# }}}
	def list_groups(self): # {{{
		'''Show selection of groups to choose.'''
		self.refresh = lambda: self.list_groups()
		groups = []
		for g in os.listdir(os.path.join(config['data'], 'users')):
			if g == 'admin':
				continue
			groups.append([g])
			for s in content.list(g):
				groups[-1].append((s, sum(users[u]['group'].lower() == g and users[u]['connection'].section == s for u in users)))
		groups.sort()
		self.remote.group_list.event(groups)
	# }}}
	def show_section(self, group, section): # {{{
		'''Show questions for one section.'''
		self.refresh = lambda: self.show_section(group, section)
		parts, index, characters = content.get(group, section)
		questions = []
		def add_block(block):
			for p in block:
				if p[0] == 'while':
					add_block(p[3])
				elif p[0] == 'if':
					for b in p[2:-1]:
						add_block(b[1])
					if p[-1] is not None:
						add_block(p[-1])
				elif p[0] == 'video':
					questions.append((p[1], os.path.splitext(p[2])[0]))
				elif p[0] in ('unit', 'number', 'short', 'long', 'choice', 'longunit', 'longnumber', 'longshort', 'longchoice'):
					questions.append((p[1], p[2]))
		add_block(parts)
		questions.append(((len(parts),), ''))
		students = []
		def make_field(student, question):
			s = student['connection']
			active = s.section == section and len(s.run_stack[-1][0]) > s.run_stack[-1][1] and s.run_stack[-1][0][s.run_stack[-1][1]][1] == question[0]
			return (active, s.answers[section][question[0]] if section in s.answers and question[0] in s.answers[section] else None)
		def make_other_field(student, question, answers):
			return (False, answers[section][question[0]] if section in answers and question[0] in answers[section] else None)
		for s in users:
			if users[s]['group'].lower() != group.lower():
				continue
			students.append((users[s]['name'], users[s]['connection'].section == section) + tuple(make_field(users[s], q) for q in questions))
		students.sort(key = lambda s: (not s[1], s[0]))
		# Add non-connected students to the list.
		others = []
		for u in list_users(group):
			if (u, group) in users:
				continue
			student, answers = load_user(u, group)
			if student is None:
				debug(0, 'student found but unloadable: {}:{}'.format(u, group))
				continue
			others.append((student['name'], None) + tuple(make_other_field(student, q, answers) for q in questions))
		others.sort()
		students.extend(others)
		self.remote.students_list.event(group, questions, students)
	# }}}
	def show_student(self, group, section, student): # {{{
		'''Show single student with detailed results for one section.'''
		self.refresh = lambda: self.show_student(group, section, student)
		# TODO.
	# }}}
# }}}

class Connection: # {{{
	def __init__(self, remote): # {{{
		debug(2, 'New connection from {}:{}'.format(*remote.socket.remote))
		self.remote = remote
		self.text_buffer = []
		self.full_section = []
		self.run_stack = []
		remote.closed = self._closed
		self.section = None	# Current section.
		self.answers = {}	# Answers that have been given to all the questions so far.
		self.variables = {}
		self.last_path = None
		q = remote.data['query']
		keys = ('name', 'group', 'secret')
		if config['secret'] != '' and all(x in q for x in keys) and q['secret'][0] == config['secret']:
			if not self._login(q['name'][0], q['group'][0]):
				self.remote.login.event()
		else:
			self.remote.login.event()
	# }}}
	def _parse_text(self, text): # {{{
		def subst(obj):
			try:
				ret = eval(obj.group(1), self.variables)
				return str(ret)
			except:
				debug(1, 'error evaluating expression substitution {}'.format(obj.group(0)))
				traceback.print_exc()
				return '[fout]'
		return re.sub('\${(.*?)}', subst, text).replace('FILE://common/', config['content'] + 'common/').replace('FILE://', config['content'] + '/' + self.user['group'].lower() + '/' + self.section + '/')
	# }}}
	def _add_text(self, text): # {{{
		'''Prepare text for displaying.'''
		if not isinstance(text, str):
			if text[0] == 'text':
				self.text_buffer.append((text[0], self._parse_text(text[1]), self._parse_text(text[2]), text[3]))
			else:
				self.text_buffer.append(text)
			return
		if len(self.text_buffer) > 0 and isinstance(self.text_buffer[-1], str):
			self.text_buffer[-1] += '\n' + self._parse_text(text)
		else:
			self.text_buffer.append(self._parse_text(text))
	# }}}
	def login(self, name, group, password): # {{{
		user, answers = load_user(name, group)
		if user is None:
			debug(2, 'Invalid user {}:{} on {}:{}'.format(name, group, *self.remote.socket.remote))
			return False
		crypted = crypt.crypt(password, salt = user['password'])
		if user['password'] is not None and crypted != user['password']:
			debug(2, 'Invalid password for {}:{} on {}:{}'.format(name, group, *self.remote.socket.remote))
			return False
		user = self._login(name, group)
		# In case the password is new, it needs to be stored.
		user['password'] = crypted
		return True
	# }}}
	def _login(self, name, group): # {{{
		user, answers = load_user(name, group)
		if user is None:
			debug(2, 'failed login for {}:{}'.format(name, group))
			return None
		if user['connection'] is not None:
			debug(2, 'Replacing connection for ' + name)
			try:
				user['connection'].remote.replaced.event()
			except:
				pass
			self.answers = user['connection'].answers
			user['connection'].remote.close()
		else:
			self.answers = answers
			users[(name.lower(), group.lower())] = user
		user['connection'] = self
		self.user = user
		debug(2, 'User {}:{} logged in from {}:{}'.format(name, group, *self.remote.socket.remote))
		self.remote.contents.event(content.list(group))
		self.remote.main.event()
		refresh_admins()
		return user
	# }}}
	def _answer(self, key, value = None): # {{{
		'''Set style for last answer.
		With only one argument, the style of the background is set.'''
		if self.last_path is None:
			debug(1, 'answer style given before a question was answered')
			return
		if value is None:
			value = key
			key = None
		if key is None:
			key = 'background'
		self.answers[self.section][self.last_path][-1][1].append((key.strip(), value.strip()))
		refresh_admins()
	# }}}
	def start(self, section): # {{{
		self.section = section
		self.full_section, self.index, characters = content.get(self.user['group'], self.section)
		self.run_stack = [[self.full_section, 0]]
		self.characters = {}
		self.last_path = None
		def goto(label):
			while len(self.run_stack) > 1:
				self.run_stack.pop()
			self.run_stack[-1][1] = self.index(label)
		self.variables = {
				'answer': self._answer,
				'goto': goto,
				'text': self._add_text,
				'test': lambda value, target, error = 1e-6: abs(value - target) < target * error,
				'character': lambda tag, name, url: self._add_character(tag, name, config['content'] + '/' + self.user['group'].lower() + '/' + section + '/' + os.path.splitext(url)[0] + '/', os.path.splitext(url)[1]),
				'say': self._say,
				'show': self._show,
				'hide': self._hide,
				'question': self._question,
				'user': self.user,
				'self': self,
				}
		for c in characters:
			self._add_character(c, *characters[c])
		self._run()
	# }}}
	def _question(self, qtype, params = ()): # {{{
		if qtype == 'unit':
			qtype = 'short'
		self._handle_story(qtype, self.text_buffer, params)
		self.text_buffer = []
		self.breaking = True
		return True
	# }}}
	def _add_character(self, code, name, imgs, ext): # {{{
		self.characters[code] = [name, imgs, ext]
		self.variables[code] = lambda text: self._say(self.characters[code][0], text, image = self.characters[code][1] + 'side' + self.characters[code][2] if self.characters[code][2] else None)
	# }}}
	def _say(self, name, text, image = None): # {{{
		self.text_buffer.append(('text', name, self._parse_text(text), image))
	# }}}
	def _show(self, tag, mod = None, at = 'center', transition = None): # {{{
		self._run_item(['story', None, content.showhide(True, tag, mod, at, transition, self.characters, None, None)])
	# }}}
	def _hide(self, tag, at = 'center', transition = None): # {{{
		self._run_item(['story', None, content.showhide(False, tag, None, at, transition, self.characters, None, None)])
	# }}}
	def _run(self): # {{{
		while len(self.run_stack) > 0:
			# Pop off stack levels until there's an instruction.
			while len(self.run_stack[-1][0]) <= self.run_stack[-1][1]:
				self.run_stack.pop()
				if len(self.run_stack) == 0:
					if len(self.text_buffer) > 0:
						self._handle_story('text', self.text_buffer)
						self.text_buffer = []
						self.run_stack = [[self.full_section, len(self.full_section)]]
						refresh_admins()
						return
					self.section = None
					refresh_admins()
					self.remote.main.event()
					return
			# Run instructions.
			if self._run_item(self.run_stack[-1][0][self.run_stack[-1][1]]):
				break
		refresh_admins()
	# }}}
	def _run_item(self, code): # {{{
		debug(3, '{}:{} running item {}'.format(self.user['name'], self.user['group'], repr(code)))
		if code[0] == 'label':
			pass
		elif code[0] == 'story':
			for item in code[2]:
				self._add_text(item)
		elif code[0] == 'answer':
			self._answer(code[2], code[3])
		elif code[0] == 'if':
			self.run_stack[-1][1] += 1
			for expr, target in code[2:-1]:
				if eval(expr, self.variables):
					self.run_stack.append([target, 0])
					break
			else:
				if code[-1] is not None:
					self.run_stack.append([code[-1], 0])
			return False
		elif code[0] == 'while':
			# Don't increment instruction pointer, so the loop restarts.
			if eval(code[2]):
				self.run_stack.append([code[3], 0])
			else:
				self.run_stack[-1][1] += 1
			return False
		elif code[0] == 'continue':
			while self.run_stack[-1][1] >= len(self.run_stack[-1][0]) or self.run_stack[-1][0][self.run_stack[-1][1]][0] != 'while':
				self.run_stack.pop()
			return False
		elif code[0] == 'break':
			while self.run_stack[-1][1] >= len(self.run_stack[-1][0]) or self.run_stack[-1][0][self.run_stack[-1][1]][0] != 'while':
				self.run_stack.pop()
			self.run_stack[-1][1] += 1
			return False
		elif code[0] == 'goto':
			# Break to top level and jump to requested label.
			while len(self.run_stack) > 1:
				self.run_stack.pop()
			self.run_stack[-1][1] = code[2]
			return False
		elif code[0] == 'python':
			self.breaking = False
			self.run_stack[-1][1] += 1	# Do this before running the code, so goto works.
			exec('\n'.join(code[2]), self.variables)
			return self.breaking
		elif code[0] == 'video':
			if len(self.text_buffer) > 0:
				self._handle_story('text', self.text_buffer)
				self.text_buffer = []
			else:
				self.remote.video.event(config['content'] + '/' + self.user['group'].lower() + '/' + self.section + '/' + code[2])
			return True
		else:
			# Question.
			return self._question(code[0], code[3:])
		self.run_stack[-1][1] += 1
		return False
	# }}}
	def _handle_story(self, q, text_buffer, *args): # {{{
		def handle(item):
			if isinstance(item, str):
				return markdown(item)
			# ('text', text, image_url)
			if item[0] == 'text':
				return (item[0], item[1], markdown(item[2]), item[3])
			# ('style', tag, key, value)
			if item[0] == 'style':
				return (item[0], item[1], item[2], self._parse_text(item[3]))
			# ('scene', url)
			# ('image', tag, url)
			# ('wait', seconds)
			return item
		self.remote.story.event(q, [handle(x) for x in text_buffer], *args)
	# }}}
	def answer(self, answer): # {{{
		debug(3, '{}:{} answers {}'.format(self.user['name'], self.user['group'], answer))
		if self.run_stack[-1][1] >= len(self.run_stack[-1][0]):
			self._run()
			return
		current = self.run_stack[-1][0][self.run_stack[-1][1]]
		if current[0] not in ('number', 'short', 'long', 'choice', 'unit', 'longnumber', 'longshort', 'longunit', 'longchoice'):
			debug(1, 'answer given by {}:{} for non-question: {}'.format(self.remote.socket.remote[0], self.remote.socket.remote[1], current))
			return
		store = not current[2].startswith('_')
		def parse_unit(src):
			r = re.match('\s*([+-]?[0-9]*([.,]\d*)?(e[+-]?\d+)?)\s*(\S*)\s*$', src)
			if not r:
				debug(3, 'no match for unit answer')
				answer = (None, str(src).strip())
			try:
				value = float(r.group(1).replace(',' ,'.'))
				answer = (value, r.group(4))
			except:
				answer = (None, str(src).strip())
			debug(3, 'unit-split answer: {}'.format(answer))
			return answer
		if current[0] == 'choice':
			try:
				answer = current.index(answer) - 3
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable choice answer: {}'.format(answer))
				answer = str(answer).strip()
			if len(current) == 3:
				store = False
		elif current[0] == 'longchoice':
			try:
				answer = (current.index(answer[0]) - 3, str(answer[1]).strip())
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longchoice answer: {}'.format(answer))
				answer = (None, str(answer).strip())
		elif current[0] == 'unit':
			answer = parse_unit(answer)
		elif current[0] == 'longunit':
			try:
				answer = (parse_unit(answer[0]), answer[1])
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longunit answer: {}'.format(answer))
				answer = ((None, ''), str(answer).strip())
		elif current[0].startswith('long') and current[0] != 'long':
			try:
				answer = (str(answer[0]).strip(), str(answer[1]).strip())
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable long* answer: {}'.format(answer))
				answer = ('', str(answer).strip())
		self.variables[current[2]] = answer
		if store:
			if self.section not in self.answers:
				self.answers[self.section] = {}
			path = self.run_stack[-1][0][self.run_stack[-1][1]][1]
			if path not in self.answers[self.section]:
				self.answers[self.section][path] = []
			self.answers[self.section][path].append((answer, []))
			self.last_path = path
			if not config['lazysave']:
				save_user(self.user)
		else:
			self.last_path = None
		self.run_stack[-1][1] += 1
		self._run()
	# }}}
	def video_done(self): # {{{
		if self.run_stack[-1][1] >= len(self.run_stack[-1][0]):
			self._run()
			return
		current = self.run_stack[-1][0][self.run_stack[-1][1]]
		if current[0] == 'video':
			self.run_stack[-1][1] += 1
			self._run()
	# }}}
	def text_done(self): # {{{
		if self.run_stack[-1][1] >= len(self.run_stack[-1][0]):
			self._run()
			return
		current = self.run_stack[-1][0][self.run_stack[-1][1]]
		if current[0] == 'story':
			self.run_stack[-1][1] += 1
		self._run()
	# }}}
	def _closed(self): # {{{
		self.remote.close()
		if not hasattr(self, 'user'):
			debug(2, 'connection to {}:{} lost before logging in'.format(*self.remote.socket.remote))
			return
		debug(2, 'disconnecting {}:{}'.format(self.user['name'], self.user['group']))
		save_user(self.user)
		try:
			users.pop((self.user['filename'], self.user['group'].lower()))
		except:
			pass
		refresh_admins()
	# }}}
# }}}

# Main program {{{
server = websocketd.RPChttpd(config['port'], Connection, httpdirs = ['html'], tls = False)
adminserver = websocketd.RPChttpd(config['admin-port'], Admin_Connection, httpdirs = ['admin_html'], tls = False)
print('servers are running')
websocketd.fgloop()
# }}}

# vim: set foldmethod=marker :
