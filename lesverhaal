#!/usr/bin/python3

# Imports and config. {{{
import sys
import os
import re
import crypt
import traceback
import time
import random
import fhs
import websocketd
from markdown import markdown
from websocketd import log
fhs.option('data', 'path to user and game data', default = '.')
fhs.option('port', 'network port to listen for players', default = '8000')
fhs.option('admin-port', 'network port to listen for admin', default = '8001')
fhs.option('sandbox-port', 'network port to listen for sandbox', default = '8002')
fhs.option('content', 'url to regular content', default = 'content')
fhs.option('sandbox', 'path to sandbox content, relative to <data path>/sandbox_html/', default = 'sandbox')
fhs.option('lazysave', 'Only save when user logs out (default is on every change)', default = False)
fhs.option('secret', 'If set, key to log in as any user (including admin) without cookie', default = '')
fhs.option('proxy', 'virtual proxy directory', default = '')
fhs.option('logfile', 'file for logging events', default = '')
fhs.option('loglimit', 'maximum loglevel that is written to screen', default = 1)
config = fhs.init(help = 'Visual novel style tool for students to learn with teacher monitoring options', contact = 'Bas Wijnen <wijnen@debian.org>', version = '0.1')
from debug import debug
import content
import user
# }}}

''' Log priorities: {{{
		0: Critical (system code errors)
		1: Important (user code errors)
		2: Normal (communication notifications)
		3: Debug
}}} '''
#'''

class Admin_Connection: # {{{
	def __init__(self, remote): # {{{
		self.remote = remote
		remote.closed = self._closed
		self.user = None
		try:
			if 'cookie' in self.remote.data['headers']:
				c = self.remote.data['headers']['cookie']
				kv = [chunk.strip().split('=', 1) for chunk in c.split(';')]
				kv = {x[0]: x[1] for x in kv}
				if 'name' in kv and 'key' in kv and (kv['name'], 'admin') in user.users and user.users[(kv['name'], 'admin')]['cookie'] == kv['key']:
					if self._login(kv['name']):
						return
		except IndexError:
			pass
		q = remote.data['query']
		keys = ('name', 'secret')
		if config['secret'] != '' and all(x in q for x in keys) and q['secret'][0] == config['secret']:
			if self._login(q['name'][0], 'admin'):
				return
		self.refresh = lambda: self.remote.login.event()
		self.remote.login.event()
	# }}}
	def login(self, name, password): # {{{
		u, answers = user.load(name.strip(), 'admin')
		if u is None:
			debug(2, 'Invalid admin {} from {}:{}'.format(name, *self.remote.socket.remote))
			return False
		crypted = crypt.crypt(password, salt = u['password'])
		if crypted != u['password']:
			debug(2, 'Invalid password for {} from {}:{}'.format(name, *self.remote.socket.remote))
			return False
		if not self._login(name.strip()):
			debug(2, 'Login failed for other reason')
			self.remote.login.event()
			self.refresh = lambda: self.remote.login.event()
		debug(2, 'login function returns')
		return True
	# }}}
	def _login(self, name): # {{{
		u, answers = user.load(name, 'admin')
		if u is None:
			return False
		if u['connection'] is not None:
			debug(3, 'Replacing connection for ' + name)
			try:
				u['connection'].remote.replaced.event()
			except:
				pass
			u['connection'].remote.close()
		user.users[(u['filename'], 'admin')] = u
		u['connection'] = self
		self.user = u
		if 'cookie' not in user.users[(u['filename'], 'admin')]:
			user.users[(u['filename'], 'admin')]['cookie'] = ''.join(chr(random.randrange(ord('a'), ord('z') + 1)) for _ in range(32))
		self.remote.cookie.event(u['filename'], user.users[(u['filename'], 'admin')]['cookie'])
		debug(1, 'Admin {} logged in from {}:{}'.format(name, *self.remote.socket.remote))
		user.admins[name.lower()] = self
		self.list_groups()
		return True
	# }}}
	def _closed(self): # {{{
		self.remote.close()
		if self.user is None:
			debug(2, 'admin connection to {}:{} lost before logging in'.format(*self.remote.socket.remote))
			return
		debug(1, 'disconnecting admin {}'.format(self.user['name']))
		try:
			user.users.pop((self.user['filename'], 'admin'))
		except:
			pass
		try:
			user.admins.pop(self.user['filename'])
		except:
			pass
	# }}}
	def list_groups(self): # {{{
		'''Show selection of groups to choose.'''
		self.refresh = lambda: self.list_groups()
		groups = []
		for g in os.listdir(os.path.join(config['data'], 'users')):
			if g == 'admin' or g.lower() != g:
				continue
			groups.append([g])
			chapters = content.list(g)
			keys = list(chapters.keys())
			keys.sort()
			for c in keys:
				for s in chapters[c]:
					groups[-1].append(((c, s), sum(user.users[u]['group'].lower() == g and user.users[u]['section'] == (c, s) for u in user.users)))
		groups.sort()
		self.remote.group_list.event(groups)
	# }}}
	def show_section(self, group, section): # {{{
		'''Show questions for one section.'''
		section = tuple(section)
		self.refresh = lambda: self.show_section(group, section)
		parts, index, characters, errors = content.get(group, section)
		questions = []
		prev = ['']
		def add_block(block):
			for p in block:
				if p[0] == 'while':
					add_block(p[3])
				elif p[0] == 'if':
					for b in p[2:-1]:
						add_block(b[1])
					if p[-1] is not None:
						add_block(p[-1])
				elif p[0] == 'video':
					questions.append((p[1], os.path.splitext(p[2])[0], 'video', p[0]))
				elif p[0] == 'hidden':
					questions.append((p[1], p[2], p[3], p[0]))
				elif p[0] in ('unit', 'number', 'short', 'long', 'choice', 'longunit', 'longnumber', 'longshort', 'longchoice'):
					questions.append((p[1], p[2], prev[0], p[0]))
					prev[0] = ''
				elif p[0] == 'story':
					prev[0] = str(p[2][-1])
		add_block(parts)
		questions.append(((len(parts),), '', '', 'end'))
		students = []
		def make_field(student, question):
			active = student['section'] == section and len(student['run_stack'][-1][0]) > student['run_stack'][-1][1] and student['run_stack'][-1][0][student['run_stack'][-1][1]][1] == question[0]
			return (active, student['answers'][section][question[1]] if question[3] not in ('video', 'end') and section in student['answers'] and question[1] in student['answers'][section] else None)
		def make_other_field(student, question, answers):
			return (False, answers[section][question[1]] if question[3] not in ('video', 'end') and section in answers and question[1] in answers[section] else None)
		for s in user.users:
			if user.users[s]['group'].lower() != group.lower():
				continue
			students.append(((user.users[s]['name'], s), (user.users[s]['section'] == section, user.users[s]['connection'] is not None)) + tuple(make_field(user.users[s], q) for q in questions))
		students.sort(key = lambda s: (not s[1][0], s[0][0], s[0][1]))
		# Add non-connected students to the list.
		others = []
		for u in user.list_group(group):
			if (u, group) in user.users:
				continue
			student, answers = user.load(u, group)
			if student is None:
				debug(0, 'student found but unloadable: {}:{}'.format(u, group))
				continue
			others.append(((student['name'], u), (None, False)) + tuple(make_other_field(student, q, answers) for q in questions))
		try:
			others.sort()
		except:
			pass
		students.extend(others)
		self.remote.students_list.event(group, questions, students)
	# }}}
	def show_student(self, group, section, student): # {{{
		'''Show single student with detailed results for one section.'''
		self.refresh = lambda: self.show_student(group, section, student)
		# TODO.
	# }}}
# }}}

#'''
class Connection: # {{{
	def __init__(self, remote): # {{{
		debug(2, 'New connection from {}:{}'.format(*remote.socket.remote))
		self.remote = remote
		remote.closed = self._closed
		try:
			if 'cookie' in self.remote.data['headers']:
				c = self.remote.data['headers']['cookie']
				kv = [chunk.strip().split('=', 1) for chunk in c.split(';')]
				kv = {x[0]: x[1] for x in kv}
				if 'name' in kv and 'group' in kv and 'key' in kv and (kv['name'], kv['group']) in user.users and user.users[(kv['name'], kv['group'])]['cookie'] == kv['key']:
					if self._login(kv['name'], kv['group']):
						return
		except IndexError:
			pass
		q = remote.data['query']
		keys = ('name', 'group', 'secret')
		if config['secret'] != '' and all(x in q for x in keys) and q['secret'][0] == config['secret']:
			if self._login(q['name'][0], q['group'][0]):
				return
		self.remote.login.event()
	# }}}
	def login(self, name, group, password): # {{{
		u, answers = user.load(name.strip(), group.strip())
		if u is None:
			debug(2, 'Invalid user {}:{} on {}:{}'.format(name, group, *self.remote.socket.remote))
			return 'deze naam is onbekend'
		crypted = crypt.crypt(password, salt = u['password'])
		if u['password'] is not None and crypted != u['password']:
			debug(2, 'Invalid password for {}:{} on {}:{}'.format(name, group, *self.remote.socket.remote))
			return 'dit wachtwoord is onjuist'
		u = self._login(name.strip(), group.strip())
		# In case the password is new, it needs to be stored.
		if u:
			u['password'] = crypted
		return None
	# }}}
	def _login(self, name, group): # {{{
		u, answers = user.load(name, group.lower())
		if u is None:
			debug(2, 'failed login for {}:{}'.format(name, group))
			return None
		if u['connection'] is not None:
			debug(2, 'Replacing connection for ' + name)
			try:
				u['connection'].remote.replaced.event()
			except:
				pass
			u['connection'].remote.close()
		else:
			user.users[(name.lower(), group.lower())] = u
		u['answers'] = answers
		u['connection'] = self
		self.user = u
		debug(1, 'User {}:{} logged in from {}:{}'.format(name, group, *self.remote.socket.remote))
		if 'cookie' not in u:
			u['cookie'] = ''.join(chr(random.randrange(ord('a'), ord('z') + 1)) for _ in range(32))
		if 'section' not in u:
			u['text_buffer'] = []
			u['full_section'] = []
			u['run_stack'] = []
			u['section'] = None	# Current section.
			u['variables'] = {}
			u['last_path'] = None
		self.remote.cookie.event(u['filename'], group.lower(), u['cookie'])
		self.remote.contents.event(content.list(group))
		self.remote.main.event()
		if u['section'] is not None:
			if not self._run_item(self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]]):
				debug(0, 'Bug: saved state of user {}:{} was not a waiting state'.format(name, group))
				self._run()
		user.refresh_admins()
		return u
	# }}}
	def _closed(self): # {{{
		self.remote.close()
		if not hasattr(self, 'user'):
			debug(2, 'connection to {}:{} lost before logging in'.format(*self.remote.socket.remote))
			return
		debug(1, 'disconnecting {}:{}'.format(self.user['name'], self.user['group']))
		user.save(self.user)
		self.user['connection'] = None
		# TODO: schedule a timeout for discarding user data from memory.
		user.refresh_admins()
	# }}}
	def _safe_eval(self, expr, as_str): # {{{
		try:
			ret = eval(expr, self.user['variables'])
		except:
			debug(1, 'error evaluating expression {}'.format(expr))
			traceback.print_exc()
			return '[fout]' if as_str else False
		return str(ret) if as_str else ret
	# }}}
	def _parse_text(self, text): # {{{
		def subst(obj):
			return self._safe_eval(obj.group(1), as_str = True)
		if self.user['section'] is not None and self.user['section'][0] == 'sandbox':
			filetarget = config['sandbox'] + '/' + self.user['group'].lower() + '/' + self.user['name'].lower() + '/'
		else:
			filetarget = config['content'] + '/' + self.user['group'].lower() + '/' + self.user['section'][0] + '/' + self.user['section'][1] + '/'
		return re.sub('\${(.*?)}', subst, text).replace('FILE://common/', config['content'] + 'common/').replace('FILE://', filetarget)
	# }}}
	def _add_text(self, text): # {{{
		'''Prepare text for displaying.'''
		if not isinstance(text, str):
			if text[0] == 'text':
				self.user['text_buffer'].append((text[0], '' if text[1] is None else self._parse_text(text[1]), self._parse_text(text[2]), text[3]))
			else:
				self.user['text_buffer'].append(text)
			return
		if len(self.user['text_buffer']) > 0 and isinstance(self.user['text_buffer'][-1], str):
			self.user['text_buffer'][-1] += '\n' + self._parse_text(text)
		else:
			self.user['text_buffer'].append(self._parse_text(text))
	# }}}
	def _answer(self, key, value = None): # {{{
		'''Set style for last answer.
		With only one argument, the style of the background is set.'''
		if self.user['last_path'] is None:
			debug(1, 'answer style given before a question was answered')
			return
		if value is None:
			value = key
			key = None
		if key is None:
			key = 'background'
		key = self._parse_text(key)
		value = self._parse_text(value)
		self.user['answers'][self.user['section']][self.user['last_path']][-1][1].append((key.strip(), value.strip()))
		user.refresh_admins()
	# }}}
	def home(self): # {{{
		self.user['section'] = None
		self.remote.main.event()
	# }}}
	def start(self, section): # {{{
		self.user['section'] = tuple(section)
		self._start(section, content.get(self.user['group'], self.user['section']), False)
	# }}}
	def _start(self, section, section_content, send_errors): # {{{
		self.user['full_section'], self.index, characters, errors = section_content
		if send_errors:
			if len(errors) > 0:
				errors = markdown('#Fouten\n' + '\n\n'.join(errors))
			else:
				errors = ''
			self.remote.error.event(errors)
		self.user['run_stack'] = [[self.user['full_section'], 0]]
		self.user['characters'] = {}
		self.user['last_path'] = None
		def goto(label):
			while len(self.user['run_stack']) > 1:
				self.user['run_stack'].pop()
			self.user['run_stack'][-1][1] = self.index(label)
		self.user['variables'] = {
				'answer': self._answer,
				'goto': goto,
				'text': self._add_text,
				'character': lambda tag, name, url: self._add_character(tag, name, config['content'] + '/' + self.user['group'].lower() + '/' + section[0] + '/' + section[1] + '/' + os.path.splitext(url)[0] + '/', os.path.splitext(url)[1]),
				'say': self._say,
				'show': self._show,
				'hide': self._hide,
				'question': self._question,
				'user': self.user,
				'name': self.user['name'],
				'group': self.user['group'],
				'self': self,
				}
		startup = fhs.read_data('startup.py')
		if startup is not None:
			try:
				exec(startup.read(), self.user['variables'])
			except:
				debug(1, 'Error in startup script')
				traceback.print_exc()
		for c in characters:
			self._add_character(c, *characters[c])
		self._run()
	# }}}
	def _question(self, qtype, last_answer = None, params = ()): # {{{
		if qtype == 'unit':
			qtype = 'short'
			if last_answer is not None:
				last_answer = ''.join(str(x) for x in last_answer)
		if qtype == 'longunit':
			qtype = 'longshort'
			if last_answer is not None:
				last_answer = (''.join(str(x) for x in last_answer[0]), last_answer[1])
		self._handle_story(qtype, self.user['text_buffer'], last_answer, [self._parse_text(x) for x in params])
		self.breaking = True
		return True
	# }}}
	def _add_character(self, code, name, imgs, ext): # {{{
		self.user['characters'][code] = {'name': name, 'imgs': imgs, 'ext': ext, 'mood': 'default', 'x': 0, 'y': 0}
		c = self.user['characters'][code]
		self.user['variables'][code] = lambda text: self._say(c['name'], text, image = c['imgs'] + 'side' + c['ext'] if c['ext'] else None)
	# }}}
	def _say(self, name, text, image = None): # {{{
		self.user['text_buffer'].append(('text', name, self._parse_text(text), image))
	# }}}
	def _show(self, tag, mood = None, at = 'center', transition = None, timing = None): # {{{
		self._run_item(['story', None, content.showhide(True, tag, mood, at, transition, timing, False, None)])
	# }}}
	def _hide(self, tag, at = 'center', transition = None, timing = None): # {{{
		self._run_item(['story', None, content.showhide(False, tag, None, at, transition, timing, False, None)])
	# }}}
	def _run(self): # {{{
		self.user['text_buffer'] = []
		watchdog = 0
		while len(self.user['run_stack']) > 0:
			watchdog += 1
			if watchdog > 1000:
				debug(1, 'hanging script detected: {}; killing it'.format(self.user['section']))
				self._handle_story('text', 'Het verhaal bevat helaas een fout en is gestopt.')
				self.user['text_buffer'] = []
				self.user['run_stack'] = [[self.user['full_section'], len(self.user['full_section'])]]
				user.refresh_admins()
				return
			# Pop off stack levels until there's an instruction.
			while len(self.user['run_stack'][-1][0]) <= self.user['run_stack'][-1][1]:
				self.user['run_stack'].pop()
				if len(self.user['run_stack']) == 0:
					if len(self.user['text_buffer']) > 0:
						self._handle_story('text', self.user['text_buffer'])
						self.user['text_buffer'] = []
						self.user['run_stack'] = [[self.user['full_section'], len(self.user['full_section'])]]
						user.refresh_admins()
						return
					self.user['section'] = None
					user.refresh_admins()
					self.remote.main.event()
					return
			# Run instructions.
			if self._run_item(self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]]):
				break
		user.refresh_admins()
	# }}}
	def _run_item(self, code): # {{{
		debug(3, '{}:{} running item {}'.format(self.user['name'], self.user['group'], repr(code)))
		if code[0] == 'label':
			pass
		elif code[0] == 'story':
			for item in code[2]:
				self._add_text(item)
		elif code[0] == 'answer':
			self._answer(code[2], code[3])
		elif code[0] == 'if':
			self.user['run_stack'][-1][1] += 1
			for expr, target in code[2:-1]:
				if self._safe_eval(expr, as_str = False):
					self.user['run_stack'].append([target, 0])
					break
			else:
				if code[-1] is not None:
					self.user['run_stack'].append([code[-1], 0])
			return False
		elif code[0] == 'while':
			# Don't increment instruction pointer, so the loop restarts.
			if self._safe_eval(code[2], as_str = False):
				self.user['run_stack'].append([code[3], 0])
			else:
				self.user['run_stack'][-1][1] += 1
			return False
		elif code[0] == 'continue':
			while self.user['run_stack'][-1][1] >= len(self.user['run_stack'][-1][0]) or self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]][0] != 'while':
				self.user['run_stack'].pop()
			return False
		elif code[0] == 'break':
			while self.user['run_stack'][-1][1] >= len(self.user['run_stack'][-1][0]) or self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]][0] != 'while':
				self.user['run_stack'].pop()
			self.user['run_stack'][-1][1] += 1
			return False
		elif code[0] == 'goto':
			# Break to top level and jump to requested label.
			while len(self.user['run_stack']) > 1:
				self.user['run_stack'].pop()
			self.user['run_stack'][-1][1] = code[2]
			return False
		elif code[0] == 'python':
			self.breaking = False
			self.user['run_stack'][-1][1] += 1	# Do this before running the code, so goto works.
			try:
				exec('\n'.join(code[2]), self.user['variables'])
			except:
				debug(0, 'Error in script: {}'.format(code[2]))
				traceback.print_exc()
			return self.breaking
		elif code[0] == 'video':
			if len(self.user['text_buffer']) > 0:
				self._handle_story('text', self.user['text_buffer'])
				self.user['text_buffer'] = []
			else:
				self.remote.video.event(config['content'] + '/' + self.user['group'].lower() + '/' + self.user['section'][0] + '/' + self.user['section'][1] + '/' + code[2])
			return True
		elif code[0] == 'hidden':
			self.store_answer(code[2], self._safe_eval(code[3], as_str = True))
		else:
			# Question.
			if self.user['section'] in self.user['answers'] and code[2] in self.user['answers'][self.user['section']]:
				last_answer = self.user['answers'][self.user['section']][code[2]][-1][0]
			else:
				last_answer = None
			return self._question(code[0], last_answer, code[3:])
		self.user['run_stack'][-1][1] += 1
		return False
	# }}}
	def _update_sprite(self, tag, data): # {{{
		for item in ('x', 'y', 'mood'):
			if item in data:
				self.user['characters'][tag][item] = data[item]
		c = self.user['characters'][tag]
		data['url'] = c['imgs'] + (data.pop('mood') if 'mood' in data else 'default') + c['ext']
	# }}}
	def _handle_story(self, q, text_buffer, last_answer = None, *args): # {{{
		def handle(item):
			if isinstance(item, str):
				return markdown(item)

			# ('text', text, image_url)
			if item[0] == 'text':
				return (item[0], item[1], markdown(item[2]), item[3])

			# ('sprite', tag, {x, y, rotation, scale, mood, animation})
			if item[0] == 'sprite':
				if item[2] is None:
					data = None
				else:
					data = item[2].copy()
					self._update_sprite(item[1], data)
				return (item[0], item[1], data)
			if item[0].endswith('image'):
				c = self.user['characters'][item[1]]
				if item[0] == 'temp-image':
					return ('sprite', item[1], {'url': item[2] and c['imgs'] + item[2] + c['ext']})
				elif item[0] == 'restore-image':
					return ('sprite', item[1], {'url': current and c['imgs'] + current + c['ext']})

			# ('scene', url)
			# ('animation', tag, anim)
			# ('wait', seconds)
			return item
		self.remote.story.event(q, [handle(x) for x in text_buffer], last_answer, *args)
	# }}}
	def store_answer(self, question, answer, store = True): # {{{
		self.user['variables'][question] = answer
		if store:
			if self.user['section'] not in self.user['answers']:
				self.user['answers'][self.user['section']] = {}
			if question not in self.user['answers'][self.user['section']]:
				self.user['answers'][self.user['section']][question] = []
			if len(self.user['answers'][self.user['section']][question]) == 0 or answer != self.user['answers'][self.user['section']][question][-1]:
				self.user['answers'][self.user['section']][question].append((answer, []))
			self.user['last_path'] = question
			if not config['lazysave']:
				user.save(self.user)
		else:
			self.user['last_path'] = None
	# }}}
	def answer(self, answer): # {{{
		debug(3, '{}:{} answers {}'.format(self.user['name'], self.user['group'], answer))
		if self.user['run_stack'][-1][1] >= len(self.user['run_stack'][-1][0]):
			self._run()
			return
		current = self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]]
		if current[0] not in ('number', 'short', 'long', 'choice', 'unit', 'longnumber', 'longshort', 'longunit', 'longchoice'):
			debug(1, 'answer given by {}:{} for non-question: {}'.format(self.remote.socket.remote[0], self.remote.socket.remote[1], current))
			return
		store = not current[2].startswith('_')
		def parse_unit(src):
			r = re.match('\s*([+-]?[0-9]*([.,]\d*)?(e[+-]?\d+)?)\s*(\S*)\s*$', src)
			if not r:
				debug(3, 'no match for unit answer')
				answer = (None, str(src).strip())
			try:
				value = float(r.group(1).replace(',' ,'.'))
				answer = (value, r.group(4))
			except:
				answer = (None, str(src).strip())
			debug(3, 'unit-split answer: {}'.format(answer))
			return answer
		if current[0] == 'choice':
			if not 0 <= answer < len(current) - 3:
				answer = None
			if len(current) == 3:
				store = False
		elif current[0] == 'longchoice':
			if 0 <= answer[0] < len(current) - 3:
				answer = (answer[0], str(answer[1]).strip())
			else:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longchoice answer: {}'.format(answer))
				answer = (None, str(answer).strip())
		elif current[0] == 'unit':
			answer = parse_unit(answer)
		elif current[0] == 'longunit':
			try:
				answer = (parse_unit(answer[0]), answer[1])
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longunit answer: {}'.format(answer))
				answer = ((None, ''), str(answer).strip())
		elif current[0].startswith('long') and current[0] != 'long':
			try:
				answer = (str(answer[0]).strip(), str(answer[1]).strip())
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable long* answer: {}'.format(answer))
				answer = ('', str(answer).strip())
		self.store_answer(current[2], answer, store)
		self.user['run_stack'][-1][1] += 1
		self._run()
	# }}}
	def video_done(self): # {{{
		if self.user['run_stack'][-1][1] >= len(self.user['run_stack'][-1][0]):
			self._run()
			return
		current = self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]]
		if current[0] == 'video':
			self.user['run_stack'][-1][1] += 1
			self._run()
	# }}}
	def text_done(self): # {{{
		if self.user['run_stack'][-1][1] >= len(self.user['run_stack'][-1][0]):
			self._run()
			return
		current = self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]]
		if current[0] == 'story':
			self.user['run_stack'][-1][1] += 1
		self._run()
	# }}}
	def sandbox_list(self): # {{{
		if not self.user['sandbox']:
			debug(1, 'User {}:{} is not allowed to use sandbox'.format(self.user['name'], self.user['group']))
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'sandbox_html', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		if not os.path.exists(basedir):
			return []
		def make_list(base, current):
			ret = []
			for f in os.listdir(os.path.join(base, current)):
				filename = os.path.join(base, current, f)
				if os.path.isdir(filename):
					if f[0] == '.':
						continue
					ret.extend(make_list(base, os.path.join(current, f)))
				else:
					ret.append(os.path.join(current, f))
			return ret
		return make_list(basedir, '')
	# }}}
	def sandbox_remove(self, name): # {{{
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'sandbox_html', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(name)
		assert '.' not in d and os.path.exists(os.path.join(basedir, name))
		os.unlink(os.path.join(basedir, name))
	# }}}
	def sandbox_play(self, scriptname): # {{{
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'sandbox_html', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(scriptname)
		assert '.' not in d and os.path.exists(os.path.join(basedir, scriptname))
		self.user['section'] = ('sandbox', self.user['name'].lower())
		self._start(self.user['section'], content.get_file(self.user['group'], self.user['section'], os.path.join(basedir, scriptname)), True)
	# }}}
	def sandbox_get(self, name): # {{{
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'sandbox_html', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(name)
		assert '.' not in d and os.path.exists(os.path.join(basedir, name))
		return open(os.path.join(basedir, name)).read()
	# }}}
	def sandbox_put(self, name, contents): # {{{
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'sandbox_html', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(name)
		assert '.' not in d
		os.makedirs(basedir, exist_ok = True)
		open(os.path.join(basedir, name), 'w').write(contents)
	# }}}

def sandbox_post(connection): # {{{
	'''Upload a new file for the sandbox.
	Credentials must be provided in the cookie. User must be allowed to use the sandbox.
	'''
	if 'cookie' not in connection.headers or 'file' not in connection.post[1]:
		debug(1, 'ignoring invalid POST request')
		sandboxserver.reply(connection, 404, 'invalid POST request', 'text/plain;charset=utf-8')
		return False
	c = connection.headers['cookie']
	kv = [chunk.strip().split('=', 1) for chunk in c.split(';')]
	kv = {x[0]: x[1] for x in kv}
	if 'name' not in kv or 'group' not in kv or 'key' not in kv or (kv['name'], kv['group']) not in user.users or user.users[(kv['name'], kv['group'])]['cookie'] != kv['key']:
		debug(1, 'invalid cookie for POST')
		sandboxserver.reply(connection, 403, 'invalid cookie for POST request', 'text/plain;charset=utf-8')
		return False
	u = user.users[(kv['name'], kv['group'])]
	if not u['sandbox']:
		debug(1, 'User is not allowed to use sandbox')
		sandboxserver.reply(connection, 403, b'User is not allowed to use sandbox', 'text/plain;charset=utf-8')
		return False
	# Credentials are good, save the files.
	basedir = os.path.join(config['data'], 'sandbox_html', config['sandbox'], kv['group'].lower(), kv['name'].lower())
	for f in connection.post[1]['file']:
		basename = os.path.basename(f[1]).split('.')
		if len(basename) > 1:
			basename[-2:] = [basename[-2] + '.' + basename[-1]]
		filename = os.path.join(basedir, *basename)
		os.makedirs(os.path.join(basedir, *basename[:-1]), exist_ok = True)
		# Copy the file.
		try:
			with open(filename, 'wb') as w:
				with open(f[0], 'rb') as r:
					w.write(r.read())
			debug(1, 'copied {} to {}'.format(f[0], filename))
		except:
			debug(1, 'unable to copy file')
			traceback.print_exc()
	sandboxserver.page(connection)
	return False
# }}}
# }}}

# Main program {{{
server = websocketd.RPChttpd(config['port'], Connection, httpdirs = ['html'], tls = False)
adminserver = websocketd.RPChttpd(config['admin-port'], Admin_Connection, httpdirs = ['admin_html'], tls = False)
sandboxserver = websocketd.RPChttpd(config['sandbox-port'], Connection, httpdirs = ['sandbox_html'], tls = False, proxy = config['proxy'] or ())
sandboxserver.post = sandbox_post
print('servers are running')
websocketd.fgloop()
# }}}

# vim: set foldmethod=marker :
