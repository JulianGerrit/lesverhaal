#!/usr/bin/python3

# Imports and config. {{{
import sys
import os
import re
import crypt
import traceback
import time
import random
import fhs
import websocketd
from markdown import markdown
from websocketd import log
config = fhs.init({'data': '.', 'port': '8000', 'admin-port': '8001', 'loglimit': 1, 'content': 'content', 'lazysave': False, 'secret': '', 'logfile': ''})
from debug import debug
import content
import user
# }}}

''' Log priorities: {{{
		0: Critical (system code errors)
		1: Important (user code errors)
		2: Normal (communication notifications)
		3: Debug
}}} '''
#'''

class Admin_Connection: # {{{
	def __init__(self, remote): # {{{
		self.remote = remote
		remote.closed = self._closed
		self.user = None
		try:
			if 'cookie' in self.remote.data['headers']:
				c = self.remote.data['headers']['cookie']
				kv = [chunk.strip().split('=', 1) for chunk in c.split(';')]
				kv = {x[0]: x[1] for x in kv}
				if 'name' in kv and 'key' in kv and (kv['name'], 'admin') in user.users and user.users[(kv['name'], 'admin')]['cookie'] == kv['key']:
					if self._login(kv['name']):
						return
		except IndexError:
			pass
		q = remote.data['query']
		keys = ('name', 'secret')
		if config['secret'] != '' and all(x in q for x in keys) and q['secret'][0] == config['secret']:
			if self._login(q['name'][0], 'admin'):
				return
		self.refresh = lambda: self.remote.login.event()
		self.remote.login.event()
	# }}}
	def login(self, name, password): # {{{
		u, answers = user.load(name.strip(), 'admin')
		if u is None:
			debug(2, 'Invalid admin {} from {}:{}'.format(name, *self.remote.socket.remote))
			return False
		crypted = crypt.crypt(password, salt = u['password'])
		if crypted != u['password']:
			debug(2, 'Invalid password for {} from {}:{}'.format(name, *self.remote.socket.remote))
			return False
		if not self._login(name.strip()):
			debug(2, 'Login failed for other reason')
			self.remote.login.event()
			self.refresh = lambda: self.remote.login.event()
		debug(2, 'login function returns')
		return True
	# }}}
	def _login(self, name): # {{{
		u, answers = user.load(name, 'admin')
		if u is None:
			return False
		if u['connection'] is not None:
			debug(3, 'Replacing connection for ' + name)
			try:
				u['connection'].remote.replaced.event()
			except:
				pass
			u['connection'].remote.close()
		user.users[(u['filename'], 'admin')] = u
		u['connection'] = self
		self.user = u
		if 'cookie' not in user.users[(u['filename'], 'admin')]:
			user.users[(u['filename'], 'admin')]['cookie'] = ''.join(chr(random.randrange(ord('a'), ord('z') + 1)) for _ in range(32))
		self.remote.cookie.event(u['filename'], user.users[(u['filename'], 'admin')]['cookie'])
		debug(1, 'Admin {} logged in from {}:{}'.format(name, *self.remote.socket.remote))
		user.admins[name.lower()] = self
		self.list_groups()
		return True
	# }}}
	def _closed(self): # {{{
		self.remote.close()
		if self.user is None:
			debug(2, 'admin connection to {}:{} lost before logging in'.format(*self.remote.socket.remote))
			return
		debug(1, 'disconnecting admin {}'.format(self.user['name']))
		try:
			user.users.pop((self.user['filename'], 'admin'))
		except:
			pass
		try:
			user.admins.pop(self.user['filename'])
		except:
			pass
	# }}}
	def list_groups(self): # {{{
		'''Show selection of groups to choose.'''
		self.refresh = lambda: self.list_groups()
		groups = []
		for g in os.listdir(os.path.join(config['data'], 'users')):
			if g == 'admin' or g.lower() != g:
				continue
			groups.append([g])
			chapters = content.list(g)
			keys = list(chapters.keys())
			keys.sort()
			for c in keys:
				for s in chapters[c]:
					groups[-1].append(((c, s), sum(user.users[u]['group'].lower() == g and user.users[u]['section'] == (c, s) for u in user.users)))
		groups.sort()
		self.remote.group_list.event(groups)
	# }}}
	def show_section(self, group, section): # {{{
		'''Show questions for one section.'''
		section = tuple(section)
		self.refresh = lambda: self.show_section(group, section)
		parts, index, characters = content.get(group, section)
		questions = []
		prev = ['']
		def add_block(block):
			for p in block:
				if p[0] == 'while':
					add_block(p[3])
				elif p[0] == 'if':
					for b in p[2:-1]:
						add_block(b[1])
					if p[-1] is not None:
						add_block(p[-1])
				elif p[0] == 'video':
					questions.append((p[1], os.path.splitext(p[2])[0], 'video', p[0]))
				elif p[0] in ('unit', 'number', 'short', 'long', 'choice', 'longunit', 'longnumber', 'longshort', 'longchoice'):
					questions.append((p[1], p[2], prev[0], p[0]))
					prev[0] = ''
				elif p[0] == 'story':
					prev[0] = str(p[2][-1])
		add_block(parts)
		questions.append(((len(parts),), '', '', 'end'))
		students = []
		def make_field(student, question):
			active = student['section'] == section and len(student['run_stack'][-1][0]) > student['run_stack'][-1][1] and student['run_stack'][-1][0][student['run_stack'][-1][1]][1] == question[0]
			return (active, student['answers'][section][question[1]] if question[3] not in ('video', 'end') and section in student['answers'] and question[1] in student['answers'][section] else None)
		def make_other_field(student, question, answers):
			return (False, answers[section][question[1]] if question[3] not in ('video', 'end') and section in answers and question[1] in answers[section] else None)
		for s in user.users:
			if user.users[s]['group'].lower() != group.lower():
				continue
			students.append(((user.users[s]['name'], s), (user.users[s]['section'] == section, user.users[s]['connection'] is not None)) + tuple(make_field(user.users[s], q) for q in questions))
		students.sort(key = lambda s: (not s[1][0], s[0][0], s[0][1]))
		# Add non-connected students to the list.
		others = []
		for u in user.list_group(group):
			if (u, group) in user.users:
				continue
			student, answers = user.load(u, group)
			if student is None:
				debug(0, 'student found but unloadable: {}:{}'.format(u, group))
				continue
			others.append(((student['name'], u), (None, False)) + tuple(make_other_field(student, q, answers) for q in questions))
		try:
			others.sort()
		except:
			pass
		students.extend(others)
		self.remote.students_list.event(group, questions, students)
	# }}}
	def show_student(self, group, section, student): # {{{
		'''Show single student with detailed results for one section.'''
		self.refresh = lambda: self.show_student(group, section, student)
		# TODO.
	# }}}
# }}}

#'''
class Connection: # {{{
	def __init__(self, remote): # {{{
		debug(2, 'New connection from {}:{}'.format(*remote.socket.remote))
		self.remote = remote
		remote.closed = self._closed
		try:
			if 'cookie' in self.remote.data['headers']:
				c = self.remote.data['headers']['cookie']
				kv = [chunk.strip().split('=', 1) for chunk in c.split(';')]
				kv = {x[0]: x[1] for x in kv}
				if 'name' in kv and 'group' in kv and 'key' in kv and (kv['name'], kv['group']) in user.users and user.users[(kv['name'], kv['group'])]['cookie'] == kv['key']:
					if self._login(kv['name'], kv['group']):
						return
		except IndexError:
			pass
		q = remote.data['query']
		keys = ('name', 'group', 'secret')
		if config['secret'] != '' and all(x in q for x in keys) and q['secret'][0] == config['secret']:
			if self._login(q['name'][0], q['group'][0]):
				return
		self.remote.login.event()
	# }}}
	def _parse_text(self, text): # {{{
		def subst(obj):
			try:
				ret = eval(obj.group(1), self.user['variables'])
				return str(ret)
			except:
				debug(1, 'error evaluating expression substitution {}'.format(obj.group(0)))
				traceback.print_exc()
				return '[fout]'
		return re.sub('\${(.*?)}', subst, text).replace('FILE://common/', config['content'] + 'common/').replace('FILE://', config['content'] + '/' + self.user['group'].lower() + '/' + self.user['section'][0] + '/' + self.user['section'][1] + '/')
	# }}}
	def _add_text(self, text): # {{{
		'''Prepare text for displaying.'''
		if not isinstance(text, str):
			if text[0] == 'text':
				self.user['text_buffer'].append((text[0], '' if text[1] is None else self._parse_text(text[1]), self._parse_text(text[2]), text[3]))
			else:
				self.user['text_buffer'].append(text)
			return
		if len(self.user['text_buffer']) > 0 and isinstance(self.user['text_buffer'][-1], str):
			self.user['text_buffer'][-1] += '\n' + self._parse_text(text)
		else:
			self.user['text_buffer'].append(self._parse_text(text))
	# }}}
	def login(self, name, group, password): # {{{
		u, answers = user.load(name.strip(), group.strip())
		if u is None:
			debug(2, 'Invalid user {}:{} on {}:{}'.format(name, group, *self.remote.socket.remote))
			return 'deze naam is onbekend'
		crypted = crypt.crypt(password, salt = u['password'])
		if u['password'] is not None and crypted != u['password']:
			debug(2, 'Invalid password for {}:{} on {}:{}'.format(name, group, *self.remote.socket.remote))
			return 'dit wachtwoord is onjuist'
		u = self._login(name.strip(), group.strip())
		# In case the password is new, it needs to be stored.
		u['password'] = crypted
		return None
	# }}}
	def _login(self, name, group): # {{{
		u, answers = user.load(name, group.lower())
		if u is None:
			debug(2, 'failed login for {}:{}'.format(name, group))
			return None
		if u['connection'] is not None:
			debug(2, 'Replacing connection for ' + name)
			try:
				u['connection'].remote.replaced.event()
			except:
				pass
			u['connection'].remote.close()
		else:
			user.users[(name.lower(), group.lower())] = u
		u['answers'] = answers
		u['connection'] = self
		self.user = u
		debug(1, 'User {}:{} logged in from {}:{}'.format(name, group, *self.remote.socket.remote))
		if 'cookie' not in u:
			u['cookie'] = ''.join(chr(random.randrange(ord('a'), ord('z') + 1)) for _ in range(32))
		if 'section' not in u:
			u['text_buffer'] = []
			u['full_section'] = []
			u['run_stack'] = []
			u['section'] = None	# Current section.
			u['variables'] = {}
			u['last_path'] = None
		self.remote.cookie.event(u['filename'], group.lower(), u['cookie'])
		self.remote.contents.event(content.list(group))
		self.remote.main.event()
		if u['section'] is not None:
			if not self._run_item(self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]]):
				debug(0, 'Bug: saved state of user {}:{} was not a waiting state'.format(name, group))
				self._run()
		user.refresh_admins()
		return u
	# }}}
	def _answer(self, key, value = None): # {{{
		'''Set style for last answer.
		With only one argument, the style of the background is set.'''
		if self.user['last_path'] is None:
			debug(1, 'answer style given before a question was answered')
			return
		if value is None:
			value = key
			key = None
		if key is None:
			key = 'background'
		key = self._parse_text(key)
		value = self._parse_text(value)
		self.user['answers'][self.user['section']][self.user['last_path']][-1][1].append((key.strip(), value.strip()))
		user.refresh_admins()
	# }}}
	def home(self): # {{{
		self.user['section'] = None
		self.remote.main.event()
	# }}}
	def start(self, section): # {{{
		self.user['section'] = tuple(section)
		self.user['full_section'], self.index, characters = content.get(self.user['group'], self.user['section'])
		self.user['run_stack'] = [[self.user['full_section'], 0]]
		self.user['characters'] = {}
		self.user['last_path'] = None
		def goto(label):
			while len(self.user['run_stack']) > 1:
				self.user['run_stack'].pop()
			self.user['run_stack'][-1][1] = self.index(label)
		self.user['variables'] = {
				'answer': self._answer,
				'goto': goto,
				'text': self._add_text,
				'character': lambda tag, name, url: self._add_character(tag, name, config['content'] + '/' + self.user['group'].lower() + '/' + section[0] + '/' + section[1] + '/' + os.path.splitext(url)[0] + '/', os.path.splitext(url)[1]),
				'say': self._say,
				'show': self._show,
				'hide': self._hide,
				'question': self._question,
				'user': self.user,
				'name': self.user['name'],
				'group': self.user['group'],
				'self': self,
				}
		startup = fhs.read_data('startup.py')
		if startup is not None:
			exec(startup.read(), self.user['variables'])
		for c in characters:
			self._add_character(c, *characters[c])
		self._run()
	# }}}
	def _question(self, qtype, last_answer = None, params = ()): # {{{
		if qtype == 'unit':
			qtype = 'short'
		self._handle_story(qtype, self.user['text_buffer'], last_answer, params)
		self.breaking = True
		return True
	# }}}
	def _add_character(self, code, name, imgs, ext): # {{{
		self.user['characters'][code] = [name, imgs, ext]
		self.user['variables'][code] = lambda text: self._say(self.user['characters'][code][0], text, image = self.user['characters'][code][1] + 'side' + self.user['characters'][code][2] if self.user['characters'][code][2] else None)
	# }}}
	def _say(self, name, text, image = None): # {{{
		self.user['text_buffer'].append(('text', name, self._parse_text(text), image))
	# }}}
	def _show(self, tag, mod = None, at = 'center', transition = None): # {{{
		self._run_item(['story', None, content.showhide(True, tag, mod, at, transition, self.user['characters'], None, None)])
	# }}}
	def _hide(self, tag, at = 'center', transition = None): # {{{
		self._run_item(['story', None, content.showhide(False, tag, None, at, transition, self.user['characters'], None, None)])
	# }}}
	def _run(self): # {{{
		self.user['text_buffer'] = []
		while len(self.user['run_stack']) > 0:
			# Pop off stack levels until there's an instruction.
			while len(self.user['run_stack'][-1][0]) <= self.user['run_stack'][-1][1]:
				self.user['run_stack'].pop()
				if len(self.user['run_stack']) == 0:
					if len(self.user['text_buffer']) > 0:
						self._handle_story('text', self.user['text_buffer'])
						self.user['text_buffer'] = []
						self.user['run_stack'] = [[self.user['full_section'], len(self.user['full_section'])]]
						user.refresh_admins()
						return
					self.user['section'] = None
					user.refresh_admins()
					self.remote.main.event()
					return
			# Run instructions.
			if self._run_item(self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]]):
				break
		user.refresh_admins()
	# }}}
	def _run_item(self, code): # {{{
		debug(3, '{}:{} running item {}'.format(self.user['name'], self.user['group'], repr(code)))
		if code[0] == 'label':
			pass
		elif code[0] == 'story':
			for item in code[2]:
				self._add_text(item)
		elif code[0] == 'answer':
			self._answer(code[2], code[3])
		elif code[0] == 'if':
			self.user['run_stack'][-1][1] += 1
			for expr, target in code[2:-1]:
				if eval(expr, self.user['variables']):
					self.user['run_stack'].append([target, 0])
					break
			else:
				if code[-1] is not None:
					self.user['run_stack'].append([code[-1], 0])
			return False
		elif code[0] == 'while':
			# Don't increment instruction pointer, so the loop restarts.
			if eval(code[2]):
				self.user['run_stack'].append([code[3], 0])
			else:
				self.user['run_stack'][-1][1] += 1
			return False
		elif code[0] == 'continue':
			while self.user['run_stack'][-1][1] >= len(self.user['run_stack'][-1][0]) or self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]][0] != 'while':
				self.user['run_stack'].pop()
			return False
		elif code[0] == 'break':
			while self.user['run_stack'][-1][1] >= len(self.user['run_stack'][-1][0]) or self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]][0] != 'while':
				self.user['run_stack'].pop()
			self.user['run_stack'][-1][1] += 1
			return False
		elif code[0] == 'goto':
			# Break to top level and jump to requested label.
			while len(self.user['run_stack']) > 1:
				self.user['run_stack'].pop()
			self.user['run_stack'][-1][1] = code[2]
			return False
		elif code[0] == 'python':
			self.breaking = False
			self.user['run_stack'][-1][1] += 1	# Do this before running the code, so goto works.
			try:
				exec('\n'.join(code[2]), self.user['variables'])
			except:
				debug(0, 'Error in script: {}'.format(code[2]))
				traceback.print_exc()
			return self.breaking
		elif code[0] == 'video':
			if len(self.user['text_buffer']) > 0:
				self._handle_story('text', self.user['text_buffer'])
				self.user['text_buffer'] = []
			else:
				self.remote.video.event(config['content'] + '/' + self.user['group'].lower() + '/' + self.user['section'][0] + '/' + self.user['section'][1] + '/' + code[2])
			return True
		else:
			# Question.
			if self.user['section'] in self.user['answers'] and code[2] in self.user['answers'][self.user['section']]:
				last_answer = self.user['answers'][self.user['section']][code[2]][-1][0]
			else:
				last_answer = None
			return self._question(code[0], last_answer, code[3:])
		self.user['run_stack'][-1][1] += 1
		return False
	# }}}
	def _handle_story(self, q, text_buffer, last_answer = None, *args): # {{{
		def handle(item):
			if isinstance(item, str):
				return markdown(item)
			# ('text', text, image_url)
			if item[0] == 'text':
				return (item[0], item[1], markdown(item[2]), item[3])
			# ('style', tag, key, value)
			if item[0] == 'style':
				return (item[0], item[1], item[2], self._parse_text(item[3]))
			# ('scene', url)
			# ('image', tag, url)
			# ('wait', seconds)
			return item
		self.remote.story.event(q, [handle(x) for x in text_buffer], last_answer, *args)
	# }}}
	def answer(self, answer): # {{{
		debug(3, '{}:{} answers {}'.format(self.user['name'], self.user['group'], answer))
		if self.user['run_stack'][-1][1] >= len(self.user['run_stack'][-1][0]):
			self._run()
			return
		current = self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]]
		if current[0] not in ('number', 'short', 'long', 'choice', 'unit', 'longnumber', 'longshort', 'longunit', 'longchoice'):
			debug(1, 'answer given by {}:{} for non-question: {}'.format(self.remote.socket.remote[0], self.remote.socket.remote[1], current))
			return
		store = not current[2].startswith('_')
		def parse_unit(src):
			r = re.match('\s*([+-]?[0-9]*([.,]\d*)?(e[+-]?\d+)?)\s*(\S*)\s*$', src)
			if not r:
				debug(3, 'no match for unit answer')
				answer = (None, str(src).strip())
			try:
				value = float(r.group(1).replace(',' ,'.'))
				answer = (value, r.group(4))
			except:
				answer = (None, str(src).strip())
			debug(3, 'unit-split answer: {}'.format(answer))
			return answer
		if current[0] == 'choice':
			try:
				answer = current.index(answer) - 3
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable choice answer: {}'.format(answer))
				answer = str(answer).strip()
			if len(current) == 3:
				store = False
		elif current[0] == 'longchoice':
			try:
				answer = (current.index(answer[0]) - 3, str(answer[1]).strip())
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longchoice answer: {}'.format(answer))
				answer = (None, str(answer).strip())
		elif current[0] == 'unit':
			answer = parse_unit(answer)
		elif current[0] == 'longunit':
			try:
				answer = (parse_unit(answer[0]), answer[1])
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longunit answer: {}'.format(answer))
				answer = ((None, ''), str(answer).strip())
		elif current[0].startswith('long') and current[0] != 'long':
			try:
				answer = (str(answer[0]).strip(), str(answer[1]).strip())
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable long* answer: {}'.format(answer))
				answer = ('', str(answer).strip())
		self.user['variables'][current[2]] = answer
		if store:
			if self.user['section'] not in self.user['answers']:
				self.user['answers'][self.user['section']] = {}
			question = current[2]
			if question not in self.user['answers'][self.user['section']]:
				self.user['answers'][self.user['section']][question] = []
			if len(self.user['answers'][self.user['section']][question]) == 0 or answer != self.user['answers'][self.user['section']][question][-1]:
				self.user['answers'][self.user['section']][question].append((answer, []))
			self.user['last_path'] = question
			if not config['lazysave']:
				user.save(self.user)
		else:
			self.user['last_path'] = None
		self.user['run_stack'][-1][1] += 1
		self._run()
	# }}}
	def video_done(self): # {{{
		if self.user['run_stack'][-1][1] >= len(self.user['run_stack'][-1][0]):
			self._run()
			return
		current = self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]]
		if current[0] == 'video':
			self.user['run_stack'][-1][1] += 1
			self._run()
	# }}}
	def text_done(self): # {{{
		if self.user['run_stack'][-1][1] >= len(self.user['run_stack'][-1][0]):
			self._run()
			return
		current = self.user['run_stack'][-1][0][self.user['run_stack'][-1][1]]
		if current[0] == 'story':
			self.user['run_stack'][-1][1] += 1
		self._run()
	# }}}
	def _closed(self): # {{{
		self.remote.close()
		if not hasattr(self, 'user'):
			debug(2, 'connection to {}:{} lost before logging in'.format(*self.remote.socket.remote))
			return
		debug(1, 'disconnecting {}:{}'.format(self.user['name'], self.user['group']))
		user.save(self.user)
		self.user['connection'] = None
		# TODO: schedule a timeout for discarding user data from memory.
		user.refresh_admins()
	# }}}
# }}}

# Main program {{{
server = websocketd.RPChttpd(config['port'], Connection, httpdirs = ['html'], tls = False)
adminserver = websocketd.RPChttpd(config['admin-port'], Admin_Connection, httpdirs = ['admin_html'], tls = False)
print('servers are running')
websocketd.fgloop()
# }}}

# vim: set foldmethod=marker :
