#!/usr/bin/python3

# Imports and config. {{{
import sys
import os
import re
import random
import crypt
import traceback
import time
import fhs
import websocketd
from markdown import markdown
fhs.option('data', 'data directory', default = '.')
fhs.option('port', 'user port', default = '8010')
fhs.option('admin-port', 'admin port', default = '8011')
fhs.option('beamer-port', 'beamer port', default = '8012')
fhs.option('loglimit', 'highest log level to output', default = 1)
fhs.option('content', 'replacement string for FILE://', default = 'les-content')
fhs.option('lazysave', 'save only when user quits', argtype = bool)
fhs.option('secret', 'security override key', default = '')
fhs.option('logfile', 'send log to this file instead of stderr', default = '')
config = fhs.init(help = 'let students answer questions while in class', contact = 'Bas Wijnen <wijnen@debian.org>', version = '0.1')
from debug import debug
import user
# }}}

''' Log priorities: {{{
		0: Critical (system code errors)
		1: Important (user code errors)
		2: Normal (communication notifications)
		3: Debug
}}} '''

group = sys.argv[1]
variables = {}
def parse_text(text): # {{{
	def subst(obj):
		try:
			ret = eval(obj.group(1), variables)
			return str(ret)
		except:
			debug(1, 'error evaluating expression substitution {}'.format(obj.group(0)))
			traceback.print_exc()
			return '[fout]'
	debug(2, repr(text))
	return re.sub('\${(.*?)}', subst, text).replace('FILE://', config['content'] + '/')
# }}}

def user_has_pw(the_user):
	u, answers = user.load(the_user, group)
	return u['password'] is not None

all_users = user.list_group(group)
have_pw = {u: user_has_pw(u) for u in all_users}
seen = set()
all_admins = user.list_group('admin')
responses = {u: None for u in all_users}
cookies = {u: ''.join(chr(random.randrange(ord('a'), ord('z') + 1)) for _ in range(32)) for u in all_users}
admin_cookies = {u: ''.join(chr(random.randrange(ord('a'), ord('z') + 1)) for _ in range(32)) for u in all_admins}

# Read program from standard input. {{{
program = []
lineno = 0
toplevel = re.compile(r'^([A-Za-z][a-z]*)\s*:\s*(.*?)\s*$')
block = re.compile(r'^\s(.*?)\s*$')
# Read blocks. {{{
for ln in sys.stdin:
	lineno += 1
	if ln.strip() == '':
		if len(program) > 0 and program[-1]['indent'] not in (-1, None):
			program[-1]['arg'].append('')
		continue
	r = toplevel.match(ln)
	if r:
		cmd = r.group(1)
		arg = r.group(2)
		if len(arg) > 0:
			arg = [arg]
			indent = -1
		else:
			arg = []
			indent = None
		program.append({'cmd': cmd.lower(), 'case': cmd != cmd.lower(), 'arg': arg, 'indent': indent, 'lineno': lineno, 'option': []})
	else:
		r = block.match(ln)
		if r:
			if len(program) == 0:
				debug(0, '%d: block before first toplevel command is not allowed' % lineno)
				continue
			if program[-1]['indent'] == -1:
				indent = None
			else:
				indent = program[-1]['indent']
			l = r.group(1)
			if indent is not None and l[:indent].strip() != '':
				debug(0, '%d: incorrect indentation' % lineno)
			if indent is None:
				indent = len(l) - len(l.lstrip())
				program[-1]['indent'] = indent
			program[-1]['arg'].append(l[indent:].rstrip())
		else:
			debug(0, '%d: invalid line: ' % lineno + ln)
			continue
# }}}
# Combine blocks. {{{
current = 0
mc = ('choice', 'choices')
toplevel = ('python', 'term', 'terms', 'word', 'words', 'title') + mc
args = ('score', 'filter', 'option')
while current < len(program):
	p = program[current]
	if p['cmd'] not in toplevel:
		if p['cmd'] not in args:
			debug(0, '%d: ignoring invalid command ' % p['lineno'] + p['cmd'])
			continue
		if current == 0:
			debug(0, '%d: ignoring invalid initial command ' % p['lineno'] + p['cmd'])
			continue
		if p['cmd'] == 'option':
			program[current - 1]['option'].append(' '.join(p['arg']))
		else:
			program[current - 1][p['cmd']] = p['arg']
		program.pop(current)
		continue
	if p['cmd'] in mc:
		p['case'] = True
	p['arg'] = parse_text('\n'.join(p['arg']))
	if p['cmd'] != 'python':
		p['arg'] = markdown(p['arg'])
	current += 1
# }}}
# Set up scores and filters. {{{
for p in program:
	# Put this in a function to create a new scope for expr.
	run_eval = lambda expr: lambda r: eval(expr, variables, {'response': r})
	if 'filter' in p:
		p['filter'] = run_eval(p['filter'])
	else:
		p['filter'] = lambda r: r
	if 'score' in p:
		p['score'] = run_eval(p['score'])
	else:
		p['score'] = lambda r: 0
# }}}
# }}}
current = 0
def run(index): # {{{
	global current, blocked
	current = index
	blocked = set()
	if isinstance(current, int):
		while current < len(program):
			p = program[current]
			if p['cmd'] != 'python':
				break
			current += 1
			exec(p['arg'], variables)
	for u in all_users:
		responses[u] = None
		if (u, group) in user.users:
			user.users[(u, group)]['connection']._send_state()
	for a in user.admins:
		user.admins[a].remote.current.event(current)
		user.admins[a]._update_responses()
	beamerserver.broadcast.refresh(refresh_beamer())
# }}}

def update_responses(): # {{{
	for a in user.admins:
		user.admins[a]._update_responses()
	beamerserver.broadcast.refresh(refresh_beamer())
# }}}

blocked = set()
def update_blocks():
	for a in user.admins:
		user.admins[a]._update_blocks()
	beamerserver.broadcast.refresh(refresh_beamer())

freeze = None
def refresh_beamer(): # {{{
	p = program[current] if current < len(program) else {'arg': '-', 'option': []}
	p = {k: v for k, v in p.items() if k in ('cmd', 'arg', 'option')}
	if not show_answers or not current < len(program):
		return p, False, sum(responses[u] is not None for u in responses), len(user.users) - len(user.admins), {}, []
	if freeze is not None:
		return p, True, freeze[0], freeze[1]
	answers = {}
	opts = []
	for u in all_users:
		a = responses[u]
		if a is not None:
			if program[current]['cmd'] not in ('choices', 'words', 'terms'):
				a = [a]
			for opt in a:
				if opt in blocked:
					continue
				if opt not in answers:
					answers[opt] = 0
					opts.append(opt)
				answers[opt] += 1
	opts.sort(key = lambda a: answers[a])
	return p, True, answers, opts
# }}}

class Beamer_Connection: # {{{
	def __init__(self, remote): # {{{
		self.remote = remote
		self.remote.refresh.event(refresh_beamer())
	# }}}
# }}}

show_answers = False
class Admin_Connection: # {{{
	def __init__(self, remote): # {{{
		self.remote = remote
		remote.closed = self._closed
		self.remote.group.event(group)
		self.user = None
		if 'cookie' in self.remote.data['headers']:
			c = self.remote.data['headers']['cookie']
			kv = [chunk.strip().split('=', 1) for chunk in c.split(';')]
			kv = {x[0]: x[1] for x in kv}
			if 'name' in kv and 'key' in kv and kv['name'] in all_admins and admin_cookies[kv['name']] == kv['key']:
				# Session key is correct; log the user in.
				if self._login(kv['name']):
					return
		q = remote.data['query']
		keys = ('name', 'secret')
		if config['secret'] != '' and all(x in q for x in keys) and q['secret'][0] == config['secret']:
			if self._login(q['name'][0]):
				return
		self.remote.login.event()
	# }}}
	def login(self, name, password): # {{{
		debug(2, 'admin login attempt')
		u, answers = user.load(name.strip(), 'admin')
		if u is None:
			debug(2, 'Invalid admin {} from {}:{}'.format(name, *self.remote.socket.remote))
			return 'Invalid admin name'
		crypted = crypt.crypt(password, salt = u['password'])
		if crypted != u['password']:
			debug(2, 'Invalid password for {} from {}:{}'.format(name, *self.remote.socket.remote))
			return 'Invalid password'
		if not self._login(name.strip()):
			self.remote.login.event()
		return None
	# }}}
	def _login(self, name): # {{{
		new_user, answers = user.load(name, 'admin')
		if new_user is None:
			return False
		if new_user['connection'] is not None:
			debug(3, 'Replacing connection for ' + name)
			try:
				new_user['connection'].remote.replaced.event()
			except:
				pass
			new_user['connection'].remote.close()
		else:
			user.users[(name.lower(), 'admin')] = new_user
		new_user['connection'] = self
		self.user = new_user
		debug(2, 'Admin {} logged in from {}:{}'.format(name, *self.remote.socket.remote))
		user.admins[name.lower()] = self
		self.remote.cookie.event(self.user['filename'], admin_cookies[self.user['filename']])
		self.remote.program.event([{k: v for k, v in p.items() if k not in ('filter', 'score')} for p in program])
		self.remote.current.event(current)
		self._update_responses()
		self._update_blocks()
		return True
	# }}}
	def _closed(self): # {{{
		self.remote.close()
		if self.user is None:
			debug(2, 'admin connection to {}:{} lost before logging in'.format(*self.remote.socket.remote))
			return
		debug(2, 'disconnecting admin {}'.format(self.user['name']))
		try:
			user.users.pop((self.user['filename'], 'admin'))
		except:
			pass
		try:
			user.admins.pop(self.user['filename'])
		except:
			pass
	# }}}
	#'
	def _update_responses(self): # {{{
		self.remote.responses.event([(u, responses[u], 'answered' if responses[u] is not None else 'waiting' if (u, group) in user.users else 'inactive' if not have_pw[u] else 'disconnected' if u in seen else 'offline') for u in all_users])
	# }}}
	def _update_blocks(self): # {{{
		self.remote.blocked.event({b: True for b in blocked})
	# }}}
	def run(self, index): # {{{
		run(index)
	# }}}
	def refresh(self): # {{{
		self._update_responses()
		self._update_blocks()
	# }}}
	def block(self, option, value): # {{{
		if isinstance(option, list):
			option = ','.join(option)
		if value:
			blocked.add(option)
		else:
			if option in blocked:
				blocked.remove(option)
		update_blocks()
	# }}}
	def show_answers(self, show = True): # {{{
		global show_answers
		if show_answers is show:
			return
		show_answers = show
		self.freeze(show)
		adminserver.broadcast.show(show)
	# }}}
	def freeze(self, frozen = True): # {{{
		global freeze
		if (freeze is not None) == frozen:
			return
		freeze = None
		if frozen:
			freeze = refresh_beamer()[-2:]
		beamerserver.broadcast.refresh(refresh_beamer())
		adminserver.broadcast.freeze(frozen)
	# }}}
	def reset_password(self, the_user): # {{{
		u, answers = user.load(the_user.strip(), group)
		if u is None:
			debug(2, 'Invalid user {}:{} on {}:{}'.format(name, group, *self.remote.socket.remote))
			return 'deze naam is onbekend'
		u['password'] = None
		have_pw[the_user] = False
		user.refresh_admins()
		user.save(u)
	# }}}
# }}}

class Connection: # {{{
	def __init__(self, remote): # {{{
		debug(2, 'New connection from {}:{}'.format(*remote.socket.remote))
		self.remote = remote
		remote.closed = self._closed
		self.remote.group.event(group)
		self.response = None
		if 'cookie' in self.remote.data['headers']:
			c = self.remote.data['headers']['cookie']
			kv = [chunk.strip().split('=', 1) for chunk in c.split(';')]
			kv = {x[0]: x[1] for x in kv}
			if 'name' in kv and 'key' in kv and kv['name'] in all_users and cookies[kv['name']] == kv['key']:
				# Session key is correct; log the user in.
				if self._login(kv['name'], group):
					return
		q = remote.data['query']
		keys = ('name', 'group', 'secret')
		if config['secret'] != '' and all(x in q for x in keys) and q['secret'][0] == config['secret'] and keys['group'] == group:
			if self._login(q['name'][0], q['group'][0]):
				return
		self.remote.login.event()
	# }}}
	#'
	def login(self, name, password): # {{{
		debug(2, 'user login attempt {}/{}'.format(name, password))
		u, answers = user.load(name.strip(), group)
		if u is None:
			debug(2, 'Invalid user {}:{} on {}:{}'.format(name, group, *self.remote.socket.remote))
			return 'deze naam is onbekend'
		crypted = crypt.crypt(password, salt = u['password'])
		if u['password'] is not None and crypted != u['password']:
			debug(2, 'Invalid password for {}:{} on {}:{}'.format(name, group, *self.remote.socket.remote))
			return 'dit wachtwoord is onjuist'
		u = self._login(name.strip(), group.strip())
		# In case the password is new, it needs to be stored.
		if name.lower() not in have_pw or not have_pw[name.lower()]:
			u['password'] = crypted
			have_pw[name] = True
			user.refresh_admins()
			user.save(u)
		return None
	# }}}
	def _login(self, name, group): # {{{
		u, answers = user.load(name, group)
		if u is None:
			debug(2, 'failed login for {}:{}'.format(name, group))
			return None
		if u['connection'] is not None:
			debug(2, 'Replacing connection for ' + name)
			try:
				u['connection'].remote.replaced.event()
			except:
				pass
			self.answers = u['connection'].answers
			u['connection'].remote.close()
		else:
			seen.add(u['name'])
			self.answers = answers
			user.users[(name.lower(), group.lower())] = u
		u['connection'] = self
		self.user = u
		debug(2, 'User {}:{} logged in from {}:{}'.format(name, group, *self.remote.socket.remote))
		self.remote.cookie.event(self.user['filename'], cookies[self.user['filename']])
		self._send_state()
		user.refresh_admins()
		beamerserver.broadcast.refresh(refresh_beamer())
		return u
	# }}}
	def _closed(self): # {{{
		self.remote.close()
		if not hasattr(self, 'user'):
			debug(2, 'connection to {}:{} lost before logging in'.format(*self.remote.socket.remote))
			return
		debug(2, 'disconnecting {}:{}'.format(self.user['name'], self.user['group']))
		user.save(self.user)
		try:
			user.users.pop((self.user['filename'], group.lower()))
		except:
			pass
		user.refresh_admins()
		beamerserver.broadcast.refresh(refresh_beamer())
	# }}}
	def _send_state(self): # {{{
		self.remote.content.event(current, {k: v for k, v in program[current].items() if k not in ('filter', 'score')} if current < len(program) else None, responses[self.user['name'].lower()])
	# }}}
	def respond(self, serial, response): # {{{
		if serial != current:
			debug(1, 'response for wrong question received from ' + self.user['name'])
		else:
			if program[current]['cmd'] == 'word':
				response = (response.split() + [''])[0]
			elif program[current]['cmd'] == 'words':
				response = list(set(x.strip() for x in response if x.strip() != ''))
				response.sort()
				response = tuple(response)
			if not program[current]['case']:
				if program[current]['cmd'] in ('words', 'terms'):
					response = [x.lower() for x in response]
				else:
					response = response.lower()
			responses[self.user['name'].lower()] = program[current]['filter'](response)
			update_responses()
		self._send_state()
	# }}}
# }}}

# Main program {{{
server = websocketd.RPChttpd(config['port'], Connection, httpdirs = [os.path.join('les-html', 'main')], tls = False, proxy = 'les')
adminserver = websocketd.RPChttpd(config['admin-port'], Admin_Connection, httpdirs = [os.path.join('les-html', 'admin')], tls = False)
# The beamer is the same in terms of handling, but it uses different html.
beamerserver = websocketd.RPChttpd(config['beamer-port'], Beamer_Connection, httpdirs = [os.path.join('les-html', 'beamer')], tls = False)
print('servers are running')
websocketd.fgloop()
# }}}

# vim: set foldmethod=marker :
